{"version":3,"sources":["useMaskedInputProps.tsx"],"names":["React","formatWithMask","props","value","mask","onChangeText","placeholderFillCharacter","obfuscationCharacter","showObfuscatedValue","maskArray","useMemo","formattedValueResult","text","maskHasObfuscation","find","maskItem","Array","isArray","isValueObfuscated","handleChangeText","useCallback","textToFormat","masked","length","slice","result","unmasked","obfuscated","defaultPlaceholder","map","maskChar","join","undefined","inputValue","selection","start","end","placeholder"],"mappings":"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","sourcesContent":["import * as React from 'react';\n\nimport formatWithMask from './formatWithMask';\nimport type { Mask } from './formatWithMask.types';\n\ntype UseMaskedInputProps = {\n  value: string;\n  mask?: Mask;\n  onChangeText?(masked: string, unmasked: string, obfuscated: string): void;\n  showObfuscatedValue?: boolean;\n  placeholderFillCharacter?: string;\n  obfuscationCharacter?: string;\n};\n\nexport default (props: UseMaskedInputProps) => {\n  const {\n    value,\n    mask,\n    onChangeText,\n    placeholderFillCharacter = '_',\n    obfuscationCharacter,\n    showObfuscatedValue,\n  } = props;\n\n  const maskArray = React.useMemo(\n    () => (typeof mask === 'function' ? mask(value) : mask),\n    [mask, value]\n  );\n\n  const formattedValueResult = React.useMemo(() => {\n    return formatWithMask({ text: value || '', mask, obfuscationCharacter });\n  }, [mask, obfuscationCharacter, value]);\n\n  const maskHasObfuscation = React.useMemo(\n    () => maskArray && !!maskArray.find((maskItem) => Array.isArray(maskItem)),\n    [maskArray]\n  );\n\n  const isValueObfuscated = React.useMemo(\n    () => !!maskHasObfuscation && !!showObfuscatedValue,\n    [maskHasObfuscation, showObfuscatedValue]\n  );\n\n  const handleChangeText = React.useCallback(\n    (text: string) => {\n      let textToFormat = text;\n\n      if (isValueObfuscated) {\n        textToFormat = formattedValueResult.masked || '';\n\n        if (textToFormat.length > text.length) {\n          textToFormat = textToFormat.slice(0, -1);\n        } else if (textToFormat.length < text.length) {\n          textToFormat = textToFormat + text[text.length - 1];\n        }\n      }\n\n      const result = formatWithMask({ text: textToFormat, mask, obfuscationCharacter });\n\n      onChangeText && onChangeText(result.masked, result.unmasked, result.obfuscated);\n    },\n    [\n      isValueObfuscated,\n      mask,\n      obfuscationCharacter,\n      onChangeText,\n      formattedValueResult.masked,\n    ]\n  );\n\n  const defaultPlaceholder = React.useMemo(() => {\n    if (maskArray) {\n      return maskArray\n        .map((maskChar) => {\n          if (typeof maskChar === 'string') {\n            return maskChar;\n          } else {\n            return placeholderFillCharacter;\n          }\n        })\n        .join('');\n    } else {\n      return undefined;\n    }\n  }, [maskArray, placeholderFillCharacter]);\n\n  const inputValue = isValueObfuscated\n    ? formattedValueResult.obfuscated\n    : formattedValueResult.masked;\n\n  return {\n    onChangeText: handleChangeText,\n    value: inputValue,\n    selection: isValueObfuscated\n      ? { start: inputValue.length, end: inputValue.length }\n      : undefined,\n    placeholder: defaultPlaceholder,\n  };\n};\n"]}